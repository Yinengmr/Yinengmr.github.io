<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yinengmr.github.io/</id>
    <title>Danny的博客</title>
    <updated>2019-11-05T03:02:19.751Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yinengmr.github.io/"/>
    <link rel="self" href="https://yinengmr.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://yinengmr.github.io//images/avatar.png</logo>
    <icon>https://yinengmr.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Danny的博客</rights>
    <entry>
        <title type="html"><![CDATA[重学前端]]></title>
        <id>https://yinengmr.github.io//post/chong-xue-qian-duan</id>
        <link href="https://yinengmr.github.io//post/chong-xue-qian-duan">
        </link>
        <updated>2019-10-28T08:13:30.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>这两年一直零散的学习，前端后端不定时的切换，有利也有弊，前端方面一直在做pc端相关的，却忽略了移动端，事实上人们更多的在使用移动设备，因此打算从移动端角度重学前端</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>这两年一直零散的学习，前端后端不定时的切换，有利也有弊，前端方面一直在做pc端相关的，却忽略了移动端，事实上人们更多的在使用移动设备，因此打算从移动端角度重学前端</p>
</blockquote>
<h2 id="-more-1移动端的touch事件"><!-- more --><br>
1.移动端的<code>touch</code>事件</h2>
<pre><code class="language-js">/*单击操作的特点
* 1.单击只有一根手指
* 2.判断手指开始触摸和手指松开的时间差异不能大于指定的值  300/150
* 3.保证没有滑动操作，如果有抖动必须保证抖动的距离在指定范围内*/
var div=document.querySelector(&quot;div&quot;);

var startTime,startX,startY;
div.addEventListener(&quot;touchstart&quot;,function(e){
    /*判断是否只有一根手指进行操作*/
    if(e.targetTouches.length &gt; 1){ //说明不止一个手指
        return;
    }
    /*记录手指开始触摸的时间*/
    startTime=Date.now();
    /*记录当前手指的坐标*/
    startX= e.targetTouches[0].clientX;
    startY= e.targetTouches[0].clientY;
    /*来做一些与事件相关的初始化操作*/
})

/*添加手指滑动事件，当手指在屏幕上滑动时触发:move事件是持续触发*/
div.addEventListener(&quot;touchmove&quot;,function(){
    console.log(&quot;touchmove&quot;);
});

/*touchend：当手指松开时候触发，意味着当前元素上已经没有手指对象了,
所以无法通过targetTouches来获取手指对象*/
div.addEventListener(&quot;touchend&quot;,function(e){
    /*判断是否只有一根手指进行操作*/
    if(e.changedTouches.length &gt; 1){ //说明不止一个手指
        return;
    }
    /*判断时间差异  150ms*/
    console.log(Date.now()-startTime);
    if(Date.now()-startTime &gt; 150){ //长按操作
        return;
    }
    /*判断松开手指时的坐标与触摸开始时的坐标的距离差异*/
    var endX=e.changedTouches[0].clientX;
    var endY=e.changedTouches[0].clientY;
    /*这里暂且将距离差异定为6*/
    if(Math.abs(endX-startX) &lt; 6 &amp;&amp; Math.abs(endY-startY) &lt;6){
        console.log(&quot;这就是移动端的单击事件--tap事件&quot;);
        /*执行tap事件响应后的处理操作*/
    }
})

/*添加触摸意外中断事件*/
div.addEventListener(&quot;touchcancel&quot;,function(){

});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[搬运][译] 作为程序员你不能成功的 10 个迹象]]></title>
        <id>https://yinengmr.github.io//post/ban-yun-yi-zuo-wei-cheng-xu-yuan-ni-bu-neng-cheng-gong-de-10-ge-ji-xiang</id>
        <link href="https://yinengmr.github.io//post/ban-yun-yi-zuo-wei-cheng-xu-yuan-ni-bu-neng-cheng-gong-de-10-ge-ji-xiang">
        </link>
        <updated>2019-10-10T02:47:16.000Z</updated>
        <summary type="html"><![CDATA[<p>编程是人类的基本技能，就像阅读、写作和算术一样。任何人都可以通过时间和努力学习编程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>编程是人类的基本技能，就像阅读、写作和算术一样。任何人都可以通过时间和努力学习编程。</p>
<!-- more -->
<blockquote>
<p>原文地址：10 Signs You Will Suck at Programming<br>
原文作者：Jonathan Bluks<br>
译文出自：掘金翻译计划<br>
本文永久链接：github.com/xitu/gold-m…<br>
译者：xionglong58<br>
校对者：renyuhuiharrison, yzw7489757</p>
</blockquote>
<p>我经常在 Reddit、Quora 上遇到有人问，“怎样才能知道我将来会不会成为一名成功的程序员？”（事实上，这篇文章实际上是我在 Quora 上给出的答案的一个扩展。）当人们考虑更换职业，或者是对软件开发感兴趣，并且对它需要些什么感到好奇时，不可避免地会出现编程问题。<br>
我认为对没有受过任何正规计算机培训的人来说，这是一个主要障碍。你会很自然地认为，如果你不擅长编程，那么你是不可能成功的。这有点像你想成为一名演员，并想知道你是否擅长表演。<br>
作为一名 Web 全栈开发讲师，我教过很多“初学程序员”。好消息是我很少发现有无法学习编程的学生。我认为它是人类的一种基本技能，就像阅读、写作和算术一样。任何人都可以做到，这是我们人类能力的一部分，但也确实需要学习。<br>
在过去两年的教学中，我看到有很多学生努力学习编程，同时，还发现在他们的学习过程中出现的一些共同问题。如果你看一下下面的清单并联系自身情况，请放心，你会在编程的过程中受挫并且应该在你受挫时做点什么。但是，如果你仍然致力于成为开发人员的目标，那么你可以轻松地面对这些问题并做出改变。</p>
<blockquote>
<p>编程是人类的基本技能，就像阅读、写作和算术一样。任何人都可以通过时间和努力学习编程。</p>
</blockquote>
<p>下面的清单将帮助你了解你是否会在编程方面受挫，以及如果你想改变它，你可以做些什么。</p>
<h3 id="1-缺乏好奇心">1 | 缺乏好奇心</h3>
<blockquote>
<p>如果你对计算机和技术原理的缺乏好奇心，作为一个程序员，你将永远不会成功。</p>
</blockquote>
<p>学习的基本要求是对你正在学习的东西有积极兴趣。如果你没有对技术感到好奇的头脑，你就没有足够的干劲去坚持学习成功码农必备的更全面更深入的知识。</p>
<p>相比之下，技术世界就像是一片汪洋大海，它充满了有趣的领域，互相关联的思想，以及激发人类想象力的各种可能性。</p>
<blockquote>
<p><strong>找到你的好奇心：</strong> 问问自己是否真的对编程感兴趣。如果你诚实的答案是没有，那么还是去寻找你感&gt; 兴趣的东西吧，节省你自己的时间和精力。但是，如果你的回答是“是”，那么请你自己找一些你之前&gt; 没有注意到的新东西，意识到这是一个浩瀚的海洋并深入其中。</p>
</blockquote>
<h3 id="2-缺乏主动和灵活多变">2 | 缺乏主动和灵活多变</h3>
<blockquote>
<p>如果你不培养独立解决问题的能力，你就永远不会成为一个成功的程序员。</p>
</blockquote>
<p>毫无疑问，要成为一个成功的开发人员，你必须对自己的学习能力充满信心。这实际上是一项基本的生活技能 —— 如果你已经过了18岁，没有人有义务教你任何东西。这就是现实。你得自行查找信息，并帮助你去了解对自己来说哪些是重要的信息。<br>
在发展的世界里，你所需要的所有信息都可以在一个神奇的地方找到，这个地方以前被称为信息高速公路。这个庞大的图书馆有一个巨大的入口：谷歌。当你想获得技术中所需的技能时，首先要跨越的障碍是学会在谷歌中输入你想要的任何东西并获取你需要的信息。<br>
除了要做一个优秀的 googler，所有编程语言都有文档和规范，这些文档和规范非常明确地说明了该语言的工作方式。就像用字典一样 —— 当你看到一个你不认识的词时，你就会在字典中查出来。作为一名程序员，最快速、最可靠的方法就是直接阅读文档。就是这么简单。</p>
<blockquote>
<p><strong>利用资源：</strong> 要意识到所有你需要的答案都在那儿等着你。向别人寻求答案之前，一定得要求自己先使用谷歌，同时要翻阅文档。这样当你已经尝试过却没有找到你需要的答案时，也能够节省他人的时间。</p>
</blockquote>
<h3 id="3-面对问题时缺乏毅力">3 | 面对问题时缺乏毅力</h3>
<blockquote>
<p>如果你在面对问题时轻易放弃，那么作为一名程序员，你永远不会成功。</p>
</blockquote>
<p>编程的本质是解决问题。这也是发明计算机的全部原因！每当你开始编写程序时，你都会遇到一堆问题。一旦你解决了一个问题，它背后可能又会有另一个问题。你正在取得进步，但总会遇到新问题。<br>
面对一堆的问题可能会让人望而生畏、令人沮丧的。如果你觉得程序就应该是“正常工作”，那么当问题持续出现，一点一点地击溃你的信心时，你就没有精力再坚持下去。 确切地说你的工作就是找出程序为什么不能正常工作。<br>
根据我在课堂上的经验，通常每个班都有一两个学生，他们似乎比其他学生更擅长发现那些不太常见、令人费解的问题。我提醒学生，他们面对的问题越多，学习越深入和透彻的可能性就越大。如果他们能通过这些问题获得理解，他们会很快发现他们更自信，因为他们面对和解决的问题比普通学生多。</p>
<blockquote>
<p><strong>耐心地接受：</strong> 你需要意识到问题是不可避免的，问题本身不是问题，其事实上对你的挑战。你面临和克服的每一个挑战都会让你更深入地了解并更好地应对新挑战，从而迅速解决旧的挑战。</p>
</blockquote>
<h3 id="4-克服问题时没有成就感">4 | 克服问题时没有成就感</h3>
<blockquote>
<p>如果你在解决问题后没有感到兴奋和成就感，那么作为一名程序员，你永远不会成功。</p>
</blockquote>
<p>与前一个问题相关的是，一旦你成功地解决了一个问题，就缺乏“良好的感觉”。当修复 bugs 和问题变成了一个永远不会停止的单调工作时，你就会失去与克服问题的兴奋感。<br>
当你克服一个问题时，你需要的是多巴胺的释放。这类似于在视频游戏中完成一个关卡，或者解决一个像纵横填字游戏或数独这样的挑战。我们都知道坚持通过一个挑战，然后最终赢得比赛会有一种很好的感觉。但是如果你失去了感受这些感觉的能力，或者一开始从来没有真正在意过这些感受，那么你将无法体验到编程带来的快乐。如果你把编程看作是一种痛苦，你只想尽可能容易地得到结果，那么你永远不会真正成为一个成功的程序员。</p>
<blockquote>
<p><strong>庆祝胜利：</strong> 每当你解决了一个你一直在努力解决的问题时，不管这个问题有多小，都要为你的成就感到自豪，休息一下，并祝贺你自己完成了一项出色的工作。让成功的感觉渗透进身体，让你在面临下一个问题充满活力。</p>
</blockquote>
<h3 id="5-对于学习和理解没有耐心">5 | 对于学习和理解没有耐心</h3>
<blockquote>
<p>如果你对学习不耐烦，并且期望能够快速而轻松地掌握所有东西，那么你将永远不会在编程上成功。</p>
</blockquote>
<p>我们人类并不是完美的生物。即使世界的前进速度变得越来越快，计算机是其中的一个重要原因，我们也只能尽可能快地前进。我们的大脑以一定的速度工作，并且依赖我们的过去、我们的信念、我们的情绪状态、我们的健康...，我们将以不同的速度学习和整合信息。<br>
技术的世界就像一片广阔的海洋。 你永远不会走到尽头，你永远不会成为一个没有其他东西可以学习的高手。如果你让自己负担过重，你就会总有“追赶”的感觉，并总觉得自己知道的不够多。如果你不能接受你所知道的东西后再去学习一点，你就会迷失自我，然后放弃。<br>
相反，你应该享受学习之旅。你获得的每一点知识，或是新技能，都应该是让你感到兴奋。像解决问题一样，你需要让自己感到自豪，因为你认识到自己已经向前迈出了一步，即使这是一个很小的一步。</p>
<blockquote>
<p>认可你的进步：要学的东西有很多，编程的旅途永远不会结束。但是知识是需要累积的，所以要为你所知道的感到自豪，并且相信你在学习中所做的每一个努力都将为你的职业生涯打下一个坚实的知识基础。</p>
</blockquote>
<h3 id="6-对思考问题感到厌烦或疲惫">6 | 对思考问题感到厌烦或疲惫</h3>
<blockquote>
<p>如果你懒于思考，把集中注意力的思考当成乏味无聊的任务，那么你将永远不会在编程上成功。</p>
</blockquote>
<p>编程是一种思考活动。作为人类，我们确实擅长思考，但事实是，即使每天都在不自觉地思考，我们仍懒于去主动思考。如果你不养成思考问题的习惯，那么很难在一段时间内集中精力解决一个问题。<br>
这种情况的症状包括：茫然地盯着屏幕、感觉一团云笼罩着你、拖延问题、在浏览器标签之间来回切换，拼命地浏览 StackOverflow 寻找“答案”。这些迹象表明，你的精神已经受限，需要找到一条出路。<br>
在编程的时候，你会感到疲倦，并且思考就像锻炼身体一样消耗体力。当你不习惯运用你所需的精神力量时，你将很难集中注意力。但这就像去健身房一样，你实际操作的越多，你就会变得越强壮。</p>
<blockquote>
<p><strong>你的精神如同肌肉：</strong> 请相信，你的大脑就像一块肌肉 —— 当你不停使用它的时候，它在思考过程中才会变得更好和更有效率。当你把各个部件拼凑在一起并运用精神时，会发现解决方案变得容易了很多。</p>
</blockquote>
<h3 id="7-无法独立思考">7 | 无法独立思考</h3>
<blockquote>
<p>如果你期望着别人替你思考，并且不愿意认真审视自己的处境，你将永远不会成为一个真正成功的程序员。</p>
</blockquote>
<p>当你在学习新的东西时，很容易觉得你缺乏知识和经验来支撑自己的观点。采取主动或做错事/说错话似乎有风险。<br>
我们对犯错有一种固有的恐惧感。当对犯错的恐惧抑制了你的探索和好奇心时，就会扼杀你获取真正知识的能力，知识是从经验和“失败”中获得的。 当你需要依赖“大师”的观点、热门博主、最佳实践或“教科书”答案时，那么说明你还没有真正融合对编程的有用知识。<br>
你需要对什么有用，什么没用形成自己的观点。需要明白为什么你觉得你的解决方案有用，以及它的好处是什么。需要建立一个微妙的视角，去超越那些显而易见的东西。你需要能够为你的观点“辩护”，然后在这个过程中，如果你发生了改变，你就可以拥有新的观点。</p>
<blockquote>
<p><strong>自己多想想</strong>：通过你的经验和批判性思维技巧建立你自己的观点。做出合理的猜测，坚定立场，并愿意随着新信息的出现而做出改变。</p>
</blockquote>
<h3 id="8-僵化-狭隘-混乱的思维">8 | 僵化、狭隘、混乱的思维</h3>
<h3 id="9-需要正确的答案而不是鉴别出好和坏的答案">9 | 需要“正确”的答案，而不是鉴别出“好”和“坏”的答案</h3>
<h3 id="10-不注意细节">10 | 不注意细节</h3>
<h3 id="额外补充-商业化的思维">额外补充: 商业化的思维</h3>
<p>这是我注意到这样一个现象 —— 那些特别有商业头脑的学生，往往关注结果而不是过程。他们希望得到一个“可以使用的 app”，这将推动他们的商业理念向前发展，他们希望“先进入市场”，并且他们将经验积累视为他们实现商业目标的障碍。<br>
在回顾那些难以在帮助下成长为程序员的学生时，我发现对于学习过程的不耐烦，阻碍了真正地理解技术。这些学生倾向于将技术视为达到目的的手段，而不是真正地探索和享受的知识。<br>
作为对此的一个自然延伸，我发现有些学生更倾向于经商，他们在学习上很吃力，但通常会很快让自由职业客户报名参加他们自己实际上都不会的工作。他们迅速地寻找资源/模板来让项目获得客户的满意，或者将工作外包给其他人。 <strong>他们确实不擅长编程，但却很擅长让人们付钱给他们编程!</strong></p>
<p>所以我想补充的是，那些渴望创业的学生，他们在销售、人际关系和商业发展方面都很优秀，但比其他人更难以学习编程技能。他们天生渴望创造生财的门路，并将人们与解决方案联系起来，这让他们对编程中繁琐的细节失去了耐心。</p>
<h3 id="总结">总结</h3>
<p>虽然编程是一项很难学习的技能，但它肯定是大多数人都能学的。上面的清单包含了阻碍学习的一些态度和思维方式，但是大多数人可以克服它们，并在编程领域发展自己的能力 —— 如果不是精通的话。</p>
<p>如果你对学习编程感兴趣，我鼓励你开始这个旅程。记住上面的清单，网上有很多可以让你快速前进的资源，快去探索吧，你不会后悔的。</p>
<ul>
<li>如果此文章帮到了你，请记得打赏~ 感谢您的支持！</li>
</ul>
<p><img src="http://note.youdao.com/yws/res/3052/WEBRESOURCE04f19e185a45f6c230a61fbb16d99d1c" width = "260" height = "260" alt="图片名称" 
align=center></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[web前端开发能力测评题目附答案]]></title>
        <id>https://yinengmr.github.io//post/ti-mu</id>
        <link href="https://yinengmr.github.io//post/ti-mu">
        </link>
        <updated>2019-10-08T01:19:37.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>测试你有多了解 JavaScript，刷新你的知识</li>
<li>答案在问题下方的折叠部分，点击即可展开问题。祝你好运</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>测试你有多了解 JavaScript，刷新你的知识</li>
<li>答案在问题下方的折叠部分，点击即可展开问题。祝你好运</li>
</ul>
<!-- more -->
<h2 id="基础选择题15道题-45分">基础选择题（15道题 45分）</h2>
<h6 id="1-输出是什么">1. 输出是什么？</h6>
<pre><code class="language-javascript">function sayHi() {
  console.log(name)
  console.log(age)
  var name = 'Lydia'
  let age = 21
}

sayHi()
</code></pre>
<ul>
<li>A: <code>Lydia</code> 和 <code>undefined</code></li>
<li>B: <code>Lydia</code> 和 <code>ReferenceError</code></li>
<li>C: <code>ReferenceError</code> 和 <code>21</code></li>
<li>D: <code>undefined</code> 和 <code>ReferenceError</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-d">答案: D</h4>
<p>在函数内部，我们首先通过 <code>var</code> 关键字声明了 <code>name</code> 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 <code>undefined</code>。因为当我们打印 <code>name</code> 变量时还没有执行到定义变量的位置，因此变量的值保持为 <code>undefined</code>。</p>
<p>通过 <code>let</code> 和 <code>const</code> 关键字声明的变量也会提升，但是和 <code>var</code> 不同，它们不会被<i>初始化</i>。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 <code>ReferenceError</code> 错误。</p>
</p>
</details>
<hr>
<h6 id="2-输出是什么">2. 输出是什么？</h6>
<pre><code class="language-javascript">for (var i = 0; i &lt; 3; i++) {
  setTimeout(() =&gt; console.log(i), 1)
}

for (let i = 0; i &lt; 3; i++) {
  setTimeout(() =&gt; console.log(i), 1)
}
</code></pre>
<ul>
<li>A: <code>0 1 2</code> 和 <code>0 1 2</code></li>
<li>B: <code>0 1 2</code> 和 <code>3 3 3</code></li>
<li>C: <code>3 3 3</code> 和 <code>0 1 2</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c">答案: C</h4>
<p>由于 JavaScript 的事件循环，<code>setTimeout</code> 回调会在<em>遍历结束后</em>才执行。因为在第一个遍历中遍历 <code>i</code> 是通过 <code>var</code> 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，我们通过一元操作符 <code>++</code> 来每次递增 <code>i</code> 的值。当 <code>setTimeout</code> 回调执行的时候，<code>i</code> 的值等于 3。</p>
<p>在第二个遍历中，遍历 <code>i</code> 是通过 <code>let</code> 关键字声明的：通过 <code>let</code> 和 <code>const</code> 关键字声明的变量是拥有块级作用域（指的是任何在 {} 中的内容）。在每次的遍历过程中，<code>i</code> 都有一个新值，并且每个值都在循环内的作用域中。</p>
</p>
</details>
<hr>
<h6 id="3-输出是什么">3. 输出是什么？</h6>
<pre><code class="language-javascript">let c = { greeting: 'Hey!' }
let d

d = c
c.greeting = 'Hello'
console.log(d.greeting)
</code></pre>
<ul>
<li>A: <code>Hello</code></li>
<li>B: <code>undefined</code></li>
<li>C: <code>ReferenceError</code></li>
<li>D: <code>TypeError</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a">答案: A</h4>
<p>在 JavaScript 中，当设置两个对象彼此相等时，它们会通过<em>引用</em>进行交互。</p>
<p>首先，变量 <code>c</code> 的值是一个对象。接下来，我们给 <code>d</code> 分配了一个和 <code>c</code> 对象相同的引用。</p>
<img src="https://i.imgur.com/ko5k0fs.png" width="200">
<p>因此当我们改变其中一个对象时，其实是改变了所有的对象。</p>
</p>
</details>
<hr>
<h6 id="4-输出是什么">4. 输出是什么？</h6>
<pre><code class="language-javascript">let a = 3
let b = new Number(3)
let c = 3

console.log(a == b)
console.log(a === b)
console.log(b === c)
</code></pre>
<ul>
<li>A: <code>true</code> <code>false</code> <code>true</code></li>
<li>B: <code>false</code> <code>false</code> <code>true</code></li>
<li>C: <code>true</code> <code>false</code> <code>false</code></li>
<li>D: <code>false</code> <code>true</code> <code>true</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c-2">答案: C</h4>
<p><code>new Number()</code> 是一个内建的函数构造器。虽然它看着像是一个 number，但它实际上并不是一个真实的 number：它有一堆额外的功能并且它是一个对象。</p>
<p>当我们使用 <code>==</code> 操作符时，它只会检查两者是否拥有相同的<em>值</em>。因为它们的值都是 <code>3</code>，因此返回 <code>true</code>。</p>
<p>然后，当我们使用 <code>===</code> 操作符时，两者的值以及<em>类型</em>都应该是相同的。<code>new Number()</code> 是一个对象而不是 number，因此返回 <code>false</code>。</p>
</p>
</details>
<hr>
<h6 id="5-输出是什么">5. 输出是什么？</h6>
<pre><code class="language-javascript">let hello
helo = {} // 写错!
console.log(helo)
</code></pre>
<ul>
<li>A: <code>{}</code></li>
<li>B: <code>ReferenceError: helo is not defined</code></li>
<li>C: <code>undefined</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a-2">答案: A</h4>
<p>代码打印出了一个对象，这是因为我们在全局对象上创建了一个空对象！当我们将 <code>hello</code> 写错成 <code>helo</code> 时，JS 解释器实际在上浏览器中将它视为 <code>global.helo = {}</code> （或者 <code>window.helo = {}</code>）。</p>
<p>为了避免这个为题，我们可以使用 `&quot;use strict&quot;。这能确保当你声明变量时必须赋值。</p>
</p>
</details>
<hr>
<h6 id="6-输出是什么">6. 输出是什么？</h6>
<pre><code class="language-javascript">function sum(a, b) {
  return a + b
}

sum(1, '2')
</code></pre>
<ul>
<li>A: <code>NaN</code></li>
<li>B: <code>TypeError</code></li>
<li>C: <code>&quot;12&quot;</code></li>
<li>D: <code>3</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c-3">答案: C</h4>
<p>JavaScript 是一种<strong>动态类型语言</strong>：我们不指定某些变量的类型。值可以在你不知道的情况下自动转换成另一种类型，这种类型称为<strong>隐式类型转换</strong>（implicit type coercion）。<strong>Coercion</strong> 是指将一种类型转换为另一种类型。</p>
<p>在本例中，JavaScript 将数字 <code>1</code> 转换为字符串，以便函数有意义并返回一个值。在数字类型（<code>1</code>）和字符串类型（<code>'2'</code>）相加时，该数字被视为字符串。我们可以连接字符串，比如 <code>&quot;Hello&quot; + &quot;World&quot;</code>，这里发生的是 <code>&quot;1&quot; + &quot;2&quot;</code>，它返回 <code>&quot;12&quot;</code>。</p>
</p>
</details>
<hr>
<h6 id="7-输出是什么">7. 输出是什么？</h6>
<pre><code class="language-javascript">let number = 0
console.log(number++)
console.log(++number)
console.log(number)
</code></pre>
<ul>
<li>A: <code>1</code> <code>1</code> <code>2</code></li>
<li>B: <code>1</code> <code>2</code> <code>2</code></li>
<li>C: <code>0</code> <code>2</code> <code>2</code></li>
<li>D: <code>0</code> <code>1</code> <code>2</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c-4">答案: C</h4>
<p>一元<strong>后自增</strong>运算符 <code>++</code>：</p>
<ol>
<li>返回值（返回 <code>0</code>）</li>
<li>值自增（number 现在是 <code>1</code>）</li>
</ol>
<p>一元<strong>前自增</strong>运算符 <code>++</code>：</p>
<ol>
<li>值自增（number 现在是 <code>2</code>）</li>
<li>返回值（返回 <code>2</code>）</li>
</ol>
<p>结果是 <code>0 2 2</code>.</p>
</p>
</details>
<hr>
<h6 id="8-输出是什么">8. 输出是什么？</h6>
<pre><code class="language-javascript">var num = 8
var num = 10

console.log(num)
</code></pre>
<ul>
<li>A: <code>8</code></li>
<li>B: <code>10</code></li>
<li>C: <code>SyntaxError</code></li>
<li>D: <code>ReferenceError</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-b">答案: B</h4>
<p>使用 <code>var</code> 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。</p>
<p>你不能使用 <code>let</code> 或 <code>const</code> 来实现这一点，因为它们是块作用域的。</p>
</p>
</details>
<hr>
<h6 id="9-输出是什么">9. 输出是什么？</h6>
<pre><code class="language-javascript">for (let i = 1; i &lt; 5; i++) {
  if (i === 3) continue
  console.log(i)
}
</code></pre>
<ul>
<li>A: <code>1</code> <code>2</code></li>
<li>B: <code>1</code> <code>2</code> <code>3</code></li>
<li>C: <code>1</code> <code>2</code> <code>4</code></li>
<li>D: <code>1</code> <code>3</code> <code>4</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c-5">答案: C</h4>
<p>如果某个条件返回 <code>true</code>，则 <code>continue</code> 语句跳过本次迭代。</p>
</p>
</details>
<hr>
<h6 id="10-当您单击该段落时日志输出是什么">10. 当您单击该段落时，日志输出是什么？</h6>
<pre><code class="language-html">&lt;div onclick=&quot;console.log('div')&quot;&gt;
  &lt;p onclick=&quot;console.log('p')&quot;&gt;
    Click here!
  &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li>A: <code>p</code> <code>div</code></li>
<li>B: <code>div</code> <code>p</code></li>
<li>C: <code>p</code></li>
<li>D: <code>div</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a-3">答案: A</h4>
<p>如果我们点击 <code>p</code>，我们会看到两个日志：<code>p</code> 和 <code>div</code>。在事件传播期间，有三个阶段：捕获、目标和冒泡。默认情况下，事件处理程序在冒泡阶段执行（除非将 <code>useCapture</code> 设置为 <code>true</code>）。它从嵌套最深的元素向外传播。</p>
</p>
</details>
<hr>
<h6 id="11-javascript-中的一切都是">11. JavaScript 中的一切都是？</h6>
<ul>
<li>A: 基本类型与对象</li>
<li>B: 函数与对象</li>
<li>C: 只有对象</li>
<li>D: 数字与对象</li>
<li></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a-4">答案: A</h4>
<p>JavaScript 只有基本类型和对象。</p>
<p>基本类型包括 <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>bigint</code>, <code>number</code>, <code>string</code>, <code>symbol</code>。</p>
</p>
</details>
<hr>
<h6 id="12-输出是什么">12. 输出是什么?</h6>
<pre><code class="language-javascript">console.log(3 + 4 + &quot;5&quot;);
</code></pre>
<ul>
<li>A: <code>&quot;345&quot;</code></li>
<li>B: <code>&quot;75&quot;</code></li>
<li>C: <code>12</code></li>
<li>D: <code>&quot;12&quot;</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-b-2">答案: B</h4>
<p>当所有运算符的 <em>优先级</em> 相同时，计算表达式需要确定运算符的结合顺序，即从右到左还是从左往右。在这个例子中，我们只有一类运算符<code>+</code>，对于加法来说，结合顺序就是从左到右。</p>
<p><code>3 + 4</code>首先计算，得到数字<code>7</code>.</p>
<p>由于类型的强制转换，<code>7 + '5'</code>的结果是<code>&quot;75&quot;</code>. JavaScript将<code>7</code>转换成了字符串，可以参考问题15.我们可以用<code>+</code>号把两个字符串连接起来。 <code>&quot;7&quot; + &quot;5&quot;</code> 就得到了<code>&quot;75&quot;</code>.</p>
</p>
</details>
<hr>
<h6 id="13-num的值是什么">13. <code>num</code>的值是什么?</h6>
<pre><code class="language-javascript">const num = parseInt(&quot;7*6&quot;, 10);
</code></pre>
<ul>
<li>A: <code>42</code></li>
<li>B: <code>&quot;42&quot;</code></li>
<li>C: <code>7</code></li>
<li>D: <code>NaN</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c-6">答案: C</h4>
<p>只返回了字符串中第一个字母. 设定了 <em>进制</em> 后 (也就是第二个参数，指定需要解析的数字是什么进制: 十进制、十六机制、八进制、二进制等等……),<code>parseInt</code> 检查字符串中的字符是否合法. 一旦遇到一个在指定进制中不合法的字符后，立即停止解析并且忽略后面所有的字符。</p>
<p><code>*</code>就是不合法的数字字符。所以只解析到<code>&quot;7&quot;</code>，并将其解析为十进制的<code>7</code>. <code>num</code>的值即为<code>7</code>.</p>
</p>
</details>
<hr>
<h6 id="14-输出是什么">14. 输出是什么?</h6>
<pre><code class="language-javascript">const name = &quot;Lydia&quot;;
age = 21;

console.log(delete name);
console.log(delete age);
</code></pre>
<ul>
<li>A: <code>false</code>, <code>true</code></li>
<li>B: <code>&quot;Lydia&quot;</code>, <code>21</code></li>
<li>C: <code>true</code>, <code>true</code></li>
<li>D: <code>undefined</code>, <code>undefined</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a-5">答案: A</h4>
<p><code>delete</code>操作符返回一个布尔值： <code>true</code>指删除成功，否则返回<code>false</code>. 但是通过 <code>var</code>, <code>const</code> 或 <code>let</code> 关键字声明的变量无法用 <code>delete</code> 操作符来删除。</p>
<p><code>name</code>变量由<code>const</code>关键字声明，所以删除不成功:返回 <code>false</code>. 而我们设定<code>age</code>等于<code>21</code>时,我们实际上添加了一个名为<code>age</code>的属性给全局对象。对象中的属性是可以删除的，全局对象也是如此，所以<code>delete age</code>返回<code>true</code>.</p>
</p>
</details>
<hr>
<h6 id="15-输出什么">15. 输出什么?</h6>
<pre><code class="language-javascript">console.log(Number(2) === Number(2))
console.log(Boolean(false) === Boolean(false))
console.log(Symbol('foo') === Symbol('foo'))
</code></pre>
<ul>
<li>A: <code>true</code>, <code>true</code>, <code>false</code></li>
<li>B: <code>false</code>, <code>true</code>, <code>false</code></li>
<li>C: <code>true</code>, <code>false</code>, <code>true</code></li>
<li>D: <code>true</code>, <code>true</code>, <code>true</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a-6">答案: A</h4>
<p>每个<code>Symbol</code>都是完全唯一的。传递给<code>Symbol</code>的参数只是给<code>Symbol</code>的一个描述。 <code>Symbol</code>的值不依赖于传递的参数。 当我们测试相等时，我们创建了两个全新的符号：第一个<code>Symbol（'foo'）</code>，第二个<code>Symbol（'foo'）</code>, 这两个值是唯一的，彼此不相等，因此返回<code>false</code>。</p>
</p>
</details>
<hr>
<h2 id="js扩展-5道题-25分">js扩展 （5道题 25分）</h2>
<h6 id="1javascriptes6规定了几种数据类型-分别列出">1.JavaScript（ES6）规定了几种数据类型 分别列出</h6>
<details><summary><b>答案</b></summary>
<p>
答：Null Undefined String Number Boolean Object Symbol（ES6新增）
</p>
</details>
<h6 id="2null和undefined的区别">2.null和undefined的区别</h6>
<details><summary><b>答案</b></summary>
<p>
- 答: Undefined类型只有一个值 Undefined ；Null类型也只有一个值，即null。null用来表示尚未存在(未声明)的对象
</p>
</details>
<h6 id="3如何判断一个对象是否为数组">3.如何判断一个对象是否为数组</h6>
<details><summary><b>答案</b></summary>
<p>
- console.log(Array.isArray([]));
</p>
</details>
<h6 id="4axios是什么怎么使用">4.axios是什么?怎么使用?</h6>
<details><summary><b>答案</b></summary>
<p>
- 答：引入资源 `npm install axios -S` 或者 `CDN`引入，然后axios.get或axios.post。成功返回在.then函数，失败则是在.catch函数中
</p>
</details>
<h6 id="5vue-中-v-if和v-show的区别">5.Vue 中 V-if和V-show的区别</h6>
<details><summary><b>答案</b></summary>
<p>
<ul>
<li>答案：区别就是dom元素是否挂载了，v-show是dom树上有内容，不显示，display：none；v-if是dom树上无内容</li>
</ul>
</p>
</details>
<h2 id="代码实操-3道题-30分">代码实操 （3道题 30分）</h2>
<h6 id="1js打印99乘法表">1.js打印99乘法表</h6>
<details><summary><b>答案</b></summary>
<p>
<pre><code class="language-javascript">var i , j;
for(i = 1;i &lt;= 9;i ++){
    document.write(&quot;&lt;br&gt;&quot;);               // i 为行的乘数，j 为列数  每一行打印完后换行
    for(j = 1;j &lt;= i;j ++){
        sum = i * j;
        document.write(i ,&quot;*&quot;,j ,&quot;=&quot;,sum,&quot;   &quot;);     // 使 &quot;i&quot; 和 &quot;j&quot; 能打印出来
    }
}
</code></pre>
</p>
</details>
<h6 id="2不使用第三方库实现时间转换yyyy-mm-dd-hhmmss-转为-刚刚-x分钟前-x小时前-昨天-x天前">2.不使用第三方库，实现时间转换，yyyy-MM-dd hh:mm:ss 转为 '刚刚' 、'x分钟前'、'x小时前'、'昨天'、'x天前'</h6>
<details><summary><b>答案</b></summary>
<p>
https://www.cnblogs.com/iyitong/p/4688272.html
</p>
</details>
<h6 id="3可以描述new一个对象的详细过程手动实现一个new操作符">3.可以描述new一个对象的详细过程，手动实现一个new操作符</h6>
<details><summary><b>答案</b></summary>
<p>
- 答: https://www.cnblogs.com/kevin2chen/p/6418327.html
</p>
</details>
<hr>
<ul>
<li>如果此文章帮到了你，请记得打赏~ 感谢您的支持！</li>
</ul>
<p><img src="http://note.youdao.com/yws/res/3052/WEBRESOURCE04f19e185a45f6c230a61fbb16d99d1c" width = "260" height = "260" alt="图片名称" 
align=center></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[openresty 学习参考资料]]></title>
        <id>https://yinengmr.github.io//post/openresty-study</id>
        <link href="https://yinengmr.github.io//post/openresty-study">
        </link>
        <updated>2019-10-07T11:08:53.000Z</updated>
        <summary type="html"><![CDATA[<p>openresty 学习参考资料</p>
]]></summary>
        <content type="html"><![CDATA[<p>openresty 学习参考资料</p>
<!-- more -->
<p>参考网站</p>
<p><a href="http://openresty.org/cn/">OpenResty 官网</a></p>
<p><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/">OpenResty最佳实践</a><br>
<a href="https://blog.csdn.net/orangleliu/article/details/60325268">OpenResty 技能图谱以及学习要点</a><br>
<a href="http://jinnianshilongnian.iteye.com/blog/2190344">跟我学OpenResty(Nginx+Lua)开发目录贴</a><br>
<a href="https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html">agentzh 的 Nginx 教程</a><br>
<a href="https://bg2bkk.github.io/post/nginx-gdb-utils%E7%9A%84%E7%BC%96%E8%AF%91%20%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/">nginx gdb utils的编译 安装和使用</a><br>
<a href="https://segmentfault.com/a/1190000007867494">OpenResty debugger: lua-resty-repl</a><br>
<a href="http://www.guohuawei.com/archives/how-to-debug-in-openresty.html">openresty 如何调试</a><br>
<a href="http://www.cnblogs.com/dakewei/archive/2017/12/23/8093011.html">linux性能分析工具之火焰图</a><br>
<a href="https://www.jianshu.com/p/271db393cf58">使用ZeroBrane远程在线调试Openresty, Nginx的Lua程序</a></p>
<p><a href="https://luarocks.org/">Luarocks 官网</a><br>
<a href="https://www.cnblogs.com/xiangnan/p/7082511.html">将luarocks整合进openresty</a><br>
<a href="https://blog.csdn.net/fozex/article/details/27353781">为git设置代理</a></p>
<p><a href="http://luajit.org/">Luajit 官网</a><br>
<a href="https://blog.csdn.net/ecidevilin/article/details/78630176">浅入浅出LuaJIT</a><br>
<a href="https://www.cnblogs.com/zwywilliam/p/5992737.html">luajit官方性能优化指南和注解</a><br>
<a href="https://www.cnblogs.com/quicklyslow/p/4794430.html">Luajit-2.1.0-beta1的发布和生成arm64用bytecode的解脱</a><br>
<a href="https://my.oschina.net/362228416/blog/846741">penresty 应用打包并使用luajit编译lua代码实现简单加密</a></p>
]]></content>
    </entry>
</feed>