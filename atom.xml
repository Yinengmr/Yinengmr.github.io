<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yinengmr.github.io/</id>
    <title>Danny的博客</title>
    <updated>2019-10-07T11:01:33.362Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yinengmr.github.io/"/>
    <link rel="self" href="https://yinengmr.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://yinengmr.github.io//images/avatar.png</logo>
    <icon>https://yinengmr.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Danny的博客</rights>
    <entry>
        <title type="html"><![CDATA[web前端开发基础题目]]></title>
        <id>https://yinengmr.github.io//post/web-qian-duan-kai-fa-ji-chu-ti-mu</id>
        <link href="https://yinengmr.github.io//post/web-qian-duan-kai-fa-ji-chu-ti-mu">
        </link>
        <updated>2019-10-03T07:45:32.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>测试你有多了解 JavaScript，刷新你的知识</li>
<li>答案在问题下方的折叠部分，点击即可展开问题。祝你好运</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>测试你有多了解 JavaScript，刷新你的知识</li>
<li>答案在问题下方的折叠部分，点击即可展开问题。祝你好运</li>
</ul>
<!-- more -->
<h2 id="基础选择题">基础选择题</h2>
<h6 id="1-输出是什么">1. 输出是什么？</h6>
<pre><code class="language-javascript">function sayHi() {
  console.log(name)
  console.log(age)
  var name = 'Lydia'
  let age = 21
}

sayHi()
</code></pre>
<ul>
<li>A: <code>Lydia</code> 和 <code>undefined</code></li>
<li>B: <code>Lydia</code> 和 <code>ReferenceError</code></li>
<li>C: <code>ReferenceError</code> 和 <code>21</code></li>
<li>D: <code>undefined</code> 和 <code>ReferenceError</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-d">答案: D</h4>
<p>在函数内部，我们首先通过 <code>var</code> 关键字声明了 <code>name</code> 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 <code>undefined</code>。因为当我们打印 <code>name</code> 变量时还没有执行到定义变量的位置，因此变量的值保持为 <code>undefined</code>。</p>
<p>通过 <code>let</code> 和 <code>const</code> 关键字声明的变量也会提升，但是和 <code>var</code> 不同，它们不会被<i>初始化</i>。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 <code>ReferenceError</code> 错误。</p>
</p>
</details>
<hr>
<h6 id="2-输出是什么">2. 输出是什么？</h6>
<pre><code class="language-javascript">for (var i = 0; i &lt; 3; i++) {
  setTimeout(() =&gt; console.log(i), 1)
}

for (let i = 0; i &lt; 3; i++) {
  setTimeout(() =&gt; console.log(i), 1)
}
</code></pre>
<ul>
<li>A: <code>0 1 2</code> 和 <code>0 1 2</code></li>
<li>B: <code>0 1 2</code> 和 <code>3 3 3</code></li>
<li>C: <code>3 3 3</code> 和 <code>0 1 2</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c">答案: C</h4>
<p>由于 JavaScript 的事件循环，<code>setTimeout</code> 回调会在<em>遍历结束后</em>才执行。因为在第一个遍历中遍历 <code>i</code> 是通过 <code>var</code> 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，我们通过一元操作符 <code>++</code> 来每次递增 <code>i</code> 的值。当 <code>setTimeout</code> 回调执行的时候，<code>i</code> 的值等于 3。</p>
<p>在第二个遍历中，遍历 <code>i</code> 是通过 <code>let</code> 关键字声明的：通过 <code>let</code> 和 <code>const</code> 关键字声明的变量是拥有块级作用域（指的是任何在 {} 中的内容）。在每次的遍历过程中，<code>i</code> 都有一个新值，并且每个值都在循环内的作用域中。</p>
</p>
</details>
<hr>
<h6 id="3-输出是什么">3. 输出是什么？</h6>
<pre><code class="language-javascript">let c = { greeting: 'Hey!' }
let d

d = c
c.greeting = 'Hello'
console.log(d.greeting)
</code></pre>
<ul>
<li>A: <code>Hello</code></li>
<li>B: <code>undefined</code></li>
<li>C: <code>ReferenceError</code></li>
<li>D: <code>TypeError</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a">答案: A</h4>
<p>在 JavaScript 中，当设置两个对象彼此相等时，它们会通过<em>引用</em>进行交互。</p>
<p>首先，变量 <code>c</code> 的值是一个对象。接下来，我们给 <code>d</code> 分配了一个和 <code>c</code> 对象相同的引用。</p>
<img src="https://i.imgur.com/ko5k0fs.png" width="200">
<p>因此当我们改变其中一个对象时，其实是改变了所有的对象。</p>
</p>
</details>
<hr>
<h6 id="4-输出是什么">4. 输出是什么？</h6>
<pre><code class="language-javascript">let a = 3
let b = new Number(3)
let c = 3

console.log(a == b)
console.log(a === b)
console.log(b === c)
</code></pre>
<ul>
<li>A: <code>true</code> <code>false</code> <code>true</code></li>
<li>B: <code>false</code> <code>false</code> <code>true</code></li>
<li>C: <code>true</code> <code>false</code> <code>false</code></li>
<li>D: <code>false</code> <code>true</code> <code>true</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c-2">答案: C</h4>
<p><code>new Number()</code> 是一个内建的函数构造器。虽然它看着像是一个 number，但它实际上并不是一个真实的 number：它有一堆额外的功能并且它是一个对象。</p>
<p>当我们使用 <code>==</code> 操作符时，它只会检查两者是否拥有相同的<em>值</em>。因为它们的值都是 <code>3</code>，因此返回 <code>true</code>。</p>
<p>然后，当我们使用 <code>===</code> 操作符时，两者的值以及<em>类型</em>都应该是相同的。<code>new Number()</code> 是一个对象而不是 number，因此返回 <code>false</code>。</p>
</p>
</details>
<hr>
<h6 id="5-输出是什么">5. 输出是什么？</h6>
<pre><code class="language-javascript">let hello
helo = {} // 写错!
console.log(helo)
</code></pre>
<ul>
<li>A: <code>{}</code></li>
<li>B: <code>ReferenceError: helo is not defined</code></li>
<li>C: <code>undefined</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a-2">答案: A</h4>
<p>代码打印出了一个对象，这是因为我们在全局对象上创建了一个空对象！当我们将 <code>hello</code> 写错成 <code>helo</code> 时，JS 解释器实际在上浏览器中将它视为 <code>global.helo = {}</code> （或者 <code>window.helo = {}</code>）。</p>
<p>为了避免这个为题，我们可以使用 `&quot;use strict&quot;。这能确保当你声明变量时必须赋值。</p>
</p>
</details>
<hr>
<h6 id="6-输出是什么">6. 输出是什么？</h6>
<pre><code class="language-javascript">function sum(a, b) {
  return a + b
}

sum(1, '2')
</code></pre>
<ul>
<li>A: <code>NaN</code></li>
<li>B: <code>TypeError</code></li>
<li>C: <code>&quot;12&quot;</code></li>
<li>D: <code>3</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c-3">答案: C</h4>
<p>JavaScript 是一种<strong>动态类型语言</strong>：我们不指定某些变量的类型。值可以在你不知道的情况下自动转换成另一种类型，这种类型称为<strong>隐式类型转换</strong>（implicit type coercion）。<strong>Coercion</strong> 是指将一种类型转换为另一种类型。</p>
<p>在本例中，JavaScript 将数字 <code>1</code> 转换为字符串，以便函数有意义并返回一个值。在数字类型（<code>1</code>）和字符串类型（<code>'2'</code>）相加时，该数字被视为字符串。我们可以连接字符串，比如 <code>&quot;Hello&quot; + &quot;World&quot;</code>，这里发生的是 <code>&quot;1&quot; + &quot;2&quot;</code>，它返回 <code>&quot;12&quot;</code>。</p>
</p>
</details>
<hr>
<h6 id="7-输出是什么">7. 输出是什么？</h6>
<pre><code class="language-javascript">let number = 0
console.log(number++)
console.log(++number)
console.log(number)
</code></pre>
<ul>
<li>A: <code>1</code> <code>1</code> <code>2</code></li>
<li>B: <code>1</code> <code>2</code> <code>2</code></li>
<li>C: <code>0</code> <code>2</code> <code>2</code></li>
<li>D: <code>0</code> <code>1</code> <code>2</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c-4">答案: C</h4>
<p>一元<strong>后自增</strong>运算符 <code>++</code>：</p>
<ol>
<li>返回值（返回 <code>0</code>）</li>
<li>值自增（number 现在是 <code>1</code>）</li>
</ol>
<p>一元<strong>前自增</strong>运算符 <code>++</code>：</p>
<ol>
<li>值自增（number 现在是 <code>2</code>）</li>
<li>返回值（返回 <code>2</code>）</li>
</ol>
<p>结果是 <code>0 2 2</code>.</p>
</p>
</details>
<hr>
<h6 id="8-输出是什么">8. 输出是什么？</h6>
<pre><code class="language-javascript">var num = 8
var num = 10

console.log(num)
</code></pre>
<ul>
<li>A: <code>8</code></li>
<li>B: <code>10</code></li>
<li>C: <code>SyntaxError</code></li>
<li>D: <code>ReferenceError</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-b">答案: B</h4>
<p>使用 <code>var</code> 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。</p>
<p>你不能使用 <code>let</code> 或 <code>const</code> 来实现这一点，因为它们是块作用域的。</p>
</p>
</details>
<hr>
<h6 id="9-输出是什么">9. 输出是什么？</h6>
<pre><code class="language-javascript">for (let i = 1; i &lt; 5; i++) {
  if (i === 3) continue
  console.log(i)
}
</code></pre>
<ul>
<li>A: <code>1</code> <code>2</code></li>
<li>B: <code>1</code> <code>2</code> <code>3</code></li>
<li>C: <code>1</code> <code>2</code> <code>4</code></li>
<li>D: <code>1</code> <code>3</code> <code>4</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c-5">答案: C</h4>
<p>如果某个条件返回 <code>true</code>，则 <code>continue</code> 语句跳过本次迭代。</p>
</p>
</details>
<hr>
<h6 id="10-当您单击该段落时日志输出是什么">10. 当您单击该段落时，日志输出是什么？</h6>
<pre><code class="language-html">&lt;div onclick=&quot;console.log('div')&quot;&gt;
  &lt;p onclick=&quot;console.log('p')&quot;&gt;
    Click here!
  &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li>A: <code>p</code> <code>div</code></li>
<li>B: <code>div</code> <code>p</code></li>
<li>C: <code>p</code></li>
<li>D: <code>div</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a-3">答案: A</h4>
<p>如果我们点击 <code>p</code>，我们会看到两个日志：<code>p</code> 和 <code>div</code>。在事件传播期间，有三个阶段：捕获、目标和冒泡。默认情况下，事件处理程序在冒泡阶段执行（除非将 <code>useCapture</code> 设置为 <code>true</code>）。它从嵌套最深的元素向外传播。</p>
</p>
</details>
<hr>
<h6 id="11-javascript-中的一切都是">11. JavaScript 中的一切都是？</h6>
<ul>
<li>A: 基本类型与对象</li>
<li>B: 函数与对象</li>
<li>C: 只有对象</li>
<li>D: 数字与对象</li>
<li></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a-4">答案: A</h4>
<p>JavaScript 只有基本类型和对象。</p>
<p>基本类型包括 <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>bigint</code>, <code>number</code>, <code>string</code>, <code>symbol</code>。</p>
</p>
</details>
<hr>
<h6 id="12-输出是什么">12. 输出是什么?</h6>
<pre><code class="language-javascript">console.log(3 + 4 + &quot;5&quot;);
</code></pre>
<ul>
<li>A: <code>&quot;345&quot;</code></li>
<li>B: <code>&quot;75&quot;</code></li>
<li>C: <code>12</code></li>
<li>D: <code>&quot;12&quot;</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-b-2">答案: B</h4>
<p>当所有运算符的 <em>优先级</em> 相同时，计算表达式需要确定运算符的结合顺序，即从右到左还是从左往右。在这个例子中，我们只有一类运算符<code>+</code>，对于加法来说，结合顺序就是从左到右。</p>
<p><code>3 + 4</code>首先计算，得到数字<code>7</code>.</p>
<p>由于类型的强制转换，<code>7 + '5'</code>的结果是<code>&quot;75&quot;</code>. JavaScript将<code>7</code>转换成了字符串，可以参考问题15.我们可以用<code>+</code>号把两个字符串连接起来。 <code>&quot;7&quot; + &quot;5&quot;</code> 就得到了<code>&quot;75&quot;</code>.</p>
</p>
</details>
<hr>
<h6 id="13-num的值是什么">13. <code>num</code>的值是什么?</h6>
<pre><code class="language-javascript">const num = parseInt(&quot;7*6&quot;, 10);
</code></pre>
<ul>
<li>A: <code>42</code></li>
<li>B: <code>&quot;42&quot;</code></li>
<li>C: <code>7</code></li>
<li>D: <code>NaN</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-c-6">答案: C</h4>
<p>只返回了字符串中第一个字母. 设定了 <em>进制</em> 后 (也就是第二个参数，指定需要解析的数字是什么进制: 十进制、十六机制、八进制、二进制等等……),<code>parseInt</code> 检查字符串中的字符是否合法. 一旦遇到一个在指定进制中不合法的字符后，立即停止解析并且忽略后面所有的字符。</p>
<p><code>*</code>就是不合法的数字字符。所以只解析到<code>&quot;7&quot;</code>，并将其解析为十进制的<code>7</code>. <code>num</code>的值即为<code>7</code>.</p>
</p>
</details>
<hr>
<h6 id="14-输出是什么">14. 输出是什么?</h6>
<pre><code class="language-javascript">const name = &quot;Lydia&quot;;
age = 21;

console.log(delete name);
console.log(delete age);
</code></pre>
<ul>
<li>A: <code>false</code>, <code>true</code></li>
<li>B: <code>&quot;Lydia&quot;</code>, <code>21</code></li>
<li>C: <code>true</code>, <code>true</code></li>
<li>D: <code>undefined</code>, <code>undefined</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a-5">答案: A</h4>
<p><code>delete</code>操作符返回一个布尔值： <code>true</code>指删除成功，否则返回<code>false</code>. 但是通过 <code>var</code>, <code>const</code> 或 <code>let</code> 关键字声明的变量无法用 <code>delete</code> 操作符来删除。</p>
<p><code>name</code>变量由<code>const</code>关键字声明，所以删除不成功:返回 <code>false</code>. 而我们设定<code>age</code>等于<code>21</code>时,我们实际上添加了一个名为<code>age</code>的属性给全局对象。对象中的属性是可以删除的，全局对象也是如此，所以<code>delete age</code>返回<code>true</code>.</p>
</p>
</details>
<hr>
<h6 id="15-输出什么">15. 输出什么?</h6>
<pre><code class="language-javascript">console.log(Number(2) === Number(2))
console.log(Boolean(false) === Boolean(false))
console.log(Symbol('foo') === Symbol('foo'))
</code></pre>
<ul>
<li>A: <code>true</code>, <code>true</code>, <code>false</code></li>
<li>B: <code>false</code>, <code>true</code>, <code>false</code></li>
<li>C: <code>true</code>, <code>false</code>, <code>true</code></li>
<li>D: <code>true</code>, <code>true</code>, <code>true</code></li>
</ul>
<details><summary><b>答案</b></summary>
<p>
<h4 id="答案-a-6">答案: A</h4>
<p>每个<code>Symbol</code>都是完全唯一的。传递给<code>Symbol</code>的参数只是给<code>Symbol</code>的一个描述。 <code>Symbol</code>的值不依赖于传递的参数。 当我们测试相等时，我们创建了两个全新的符号：第一个<code>Symbol（'foo'）</code>，第二个<code>Symbol（'foo'）</code>, 这两个值是唯一的，彼此不相等，因此返回<code>false</code>。</p>
</p>
</details>
<hr>
]]></content>
    </entry>
</feed>